function Start-ExchangeThreadJob {
    <#
.SYNOPSIS
Works like Start-Threadjob but for Exchange and preserves the exchange state
.NOTES
This works because the new REST commands are basically CLIXML proxies via a REST API. A dynamic module is generated upon
connection to the exchange server, and it has the session context and token "hard coded" into the module.
By simply bringing this module into the runspace, it shares the same context and token.
#>
    [CmdletBinding()]
    param(
        [parameter(Mandatory)]
        [ScriptBlock]$ScriptBlock
        ,
        [parameter()]
        [string]$Name
        ,
        [parameter()]
        [ScriptBlock]$InitializationScript
        ,
        [Parameter(ValueFromPipeline)]
        [psobject[]]$InputObject
        ,
        [parameter()]
        [psobject[]]$ArgumentList
        ,
        [parameter()]
        [Int]$ThrottleLimit = 5
    )
    begin {
        #Fetch the Exchange REST autogen module.
        [string]$restModulePath = @(Get-Module tmp*).where({$_.Description -EQ 'This is a Powershell module generated by using the AutoGEN infra.' -and $_.OnRemove -LIKE '*Microsoft.Exchange.Management.ExoPowershellSnapIn*'})[-1].Path

        if (-not $restModulePath) {
            throw 'Could not find the Exchange REST module. You must run Connect-ExchangeOnline before using this command.'
        }

        [scriptblock]$ImportExchangeModules = {
            Import-Module $USING:restModulePath -Verbose:$false -WarningAction:SilentlyContinue
            Import-Module ExchangeOnlineManagement -MinimumVersion 3.0.0 -Verbose:$false
        }

        $RunBlock = [scriptblock]::Create(
            [string]$ImportExchangeModules + [Environment]::NewLine + [string]$InitializationScript + [Environment]::NewLine + [string]$ScriptBlock
          )

        $startThreadJobParams = @{
            ThrottleLimit        = $ThrottleLimit
            ScriptBlock          = $RunBlock
            Name = $null
        }

        switch ($PSBoundParameters.Keys)
        {
            'Name'
            {
                $startThreadJobParams.Name = $Name
            }
            'ArgumentList'
            {
                $startThreadJobParams.ArgumentList = $ArgumentList
            }
        }

        $n = 0

    }

    process {

        $n++

        if ($null -eq $startThreadJobParams.Name)
        {
            $startThreadJobParams.Name = "ExchangeThreadJob$n"
        }

        switch ($MyInvocation.ExpectingInput)
        {
            $true
            {
                foreach ($i in $InputObject)
                {
                    $i | Start-ThreadJob @startThreadJobParams
                }       
            }
            $false
            {
                Start-ThreadJob @startThreadJobParams
            }
        }

    }
}